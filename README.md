<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# kryptograf

```go
import "github.com/sa6mwa/kryptograf"
```

kryptograf is a Go package for exchanging AES\-128/224/256\-CFB encrypted HMAC\-SHA256 signed data or messages as either byte slices, base64 raw standard encoded strings or json streams.

Usage example:

```
k := kryptograf.NewKryptograf()
ciphertextString, err := k.EncryptToString([]byte("Hello world"))
if err != nil {
	panic(err)
}
plaintext, err := k.DecryptString(ciphertextString)
if err != nil {
	panic(err)
}
fmt.Println(string(plaintext))

newKey := kryptograf.NewKey()
if _, err := k.SetEncryptionKey(newKey); err != nil {
	panic(err)
}
ciphertextString, err := k.EncryptToString([]byte("Once upon a time..."))
if err != nil {
	panic(err)
}
plaintext, err := k.DecryptString(ciphertextString)
if err != nil {
	panic(err)
}
fmt.Println(string(plaintext))
```

You can generate a new base64 encoded key for use with SetEncryptionKey using the newkey command:

```
go run github.com/sa6mwa/kryptograf/cmd/newkey@latest
```

kryptograf Copyright \(c\) 2023 Michel Blomgren sa6mwa@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files \(the "Software"\), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Decrypt(key []byte, data []byte) ([]byte, error)](<#func-decrypt>)
- [func Encrypt(key []byte, data []byte) ([]byte, error)](<#func-encrypt>)
- [func NewKey() string](<#func-newkey>)
- [func ToBinaryEncryptionKey(base64RawStdEncoding string) ([]byte, error)](<#func-tobinaryencryptionkey>)
- [type Kryptograf](<#type-kryptograf>)
  - [func NewKryptograf() Kryptograf](<#func-newkryptograf>)


## Constants

```go
const (
    DefaultEncryptionKey string = "TfLe2CpLn6qs8t6eQmGJnFGkU8NskfcC9AWOSEFlnLY"
)
```

## Variables

```go
var (
    ErrKeyLength            error = errors.New("key length must be 16, 24 or 32 (for AES-128, AES-192 or AES-256)")
    ErrHMACValidationFailed error = errors.New("HMAC validation failed (corrupt data or wrong encryption key)")
)
```

```go
var (
    GzipByDefault bool = false
)
```

## func [Decrypt](<https://github.com/sa6mwa/kryptograf/blob/main/kryptograf.go#L412>)

```go
func Decrypt(key []byte, data []byte) ([]byte, error)
```

Decrypt authenticates and decrypts data using a 16, 24 or 32 byte long key \(for AES\-128\-CFB, AES\-224\-CFB or AES\-256\-CFB\). The data should start with a HMAC\-SHA256 hash \(32 bytes\) initialized with key. The hash function should hash the rest of data which includes an aes.BlockSize long IV and the AES\-CFB encrypted data. Returns clear\-data or error in case of failure. Returns anystore.ErrHMACValidationFailed when the key is wrong or the message is corrupt or tampered with.

## func [Encrypt](<https://github.com/sa6mwa/kryptograf/blob/main/kryptograf.go#L373>)

```go
func Encrypt(key []byte, data []byte) ([]byte, error)
```

Encrypt encrypts data using a 16, 24 or 32 byte long key \(for AES\-128\-CFB, AES\-224\-CFB or AES\-256\-CFB\). The cipher\-data is prepended with a HMAC\-SHA256 hash \(32 bytes\) and IV \(or salt if you prefer\). Same key is used for HMAC and. The format of the output data slice is:

```
b = bytes
[HMAC_of_IV_and_cipherdata_32_b][IV_16_b][cipherdata]
```

## func [NewKey](<https://github.com/sa6mwa/kryptograf/blob/main/kryptograf.go#L353>)

```go
func NewKey() string
```

NewKey generates a 32 byte base64 encoded random string for use as an AES\-256 key. Get a new key from the command line:

```
go run github.com/sa6mwa/kryptograf/cmd/newkey@latest
```

## func [ToBinaryEncryptionKey](<https://github.com/sa6mwa/kryptograf/blob/main/kryptograf.go#L443>)

```go
func ToBinaryEncryptionKey(base64RawStdEncoding string) ([]byte, error)
```

## type [Kryptograf](<https://github.com/sa6mwa/kryptograf/blob/main/kryptograf.go#L88-L176>)

```go
type Kryptograf interface {
    // GetEncryptionKey returns the instance's encryption key as a byte slice.
    GetEncryptionKey() []byte

    // SetEncryptionKey sets the instance encryption key from a base64
    // raw standard encoded string.
    SetEncryptionKey(key string) (Kryptograf, error)

    // EnableGzip will gzip the message before Encrypt or gunzip the
    // plaintext after Decrypt of ciphertext.
    EnableGzip() Kryptograf

    // DisableGzip will turn off gzipping messages before Encrypt or
    // gunzipping the plaintext after Decrypt of ciphertext.
    DisableGzip() Kryptograf

    // Returns true if the instance will gzip plaintext messages before
    // Encrypt or gunzip ciphertext after Decrypt, false if not.
    Gzip() bool

    // Encrypt enciphers (the optionally gzipped) data byte slice using
    // the instance key and returns a byte slice with encrypted data in
    // the format of the Encrypt function or error in case of
    // failure. The returned byte slice can be decrypted using
    // Kryptograf_Decrypt given matching key and value of gzip boolean.
    Encrypt(data []byte) ([]byte, error)

    // Decrypt deciphers (the optionally gzipped) data byte slice using
    // the instance key and returns a byte slice with the plaintext
    // (decrypted) data or error in case of failure. The format of the
    // ciphertext data slice is documented in the Encrypt function.
    Decrypt(data []byte) ([]byte, error)

    // Recv reads binary ciphertext from r and returns the plaintext as
    // a byte slice or error on failure.
    Recv(r io.Reader) ([]byte, error)

    // Send sends plaintext as ciphertext to io.Writer w. Returns error
    // if encryption or w.Write fails.
    Send(plaintext []byte, w io.Writer) error

    // EncryptToString encrypts data and returns the output of
    // base64.RawStdEncoding.EncodeToString or error in case encryption
    // failed.
    EncryptToString(data []byte) (string, error)

    // DecryptString passes base64RawStdEncodedData through
    // base64.RawStdEncoding.DecodeString and returns the plaintext as a
    // byte slice or error if either decryption or base64 decoding
    // failed.
    DecryptString(base64RawStdEncodedData string) ([]byte, error)

    // RecvFromJson executes at least one json.Decode on j returning
    // exactly one successfully decrypted json key/value pair as a
    // map[string][]byte or error per call. RecvFromJson uses
    // json.Decode underneath and can be repeatedly called on j until
    // returning error io.EOF indicating there is no more data to read
    // from the stream. If you require that every incoming json object
    // is successfully decrypted you can set the optional variadic
    // boolean to true, in which case RecvFromJson will return error if
    // any incoming json object fail decryption. Format of the incoming
    // json stream is:
    //
    //	{"msg1":"base64EncodedCipherText"}
    //	{"msg2":"base64EncodedCipherText"}
    //	...etc.
    //
    // RecvFromJson will decrypt json generated with
    // Kryptograf_EncryptToJson.
    //
    // Example:
    //	jsonText := `{"msgkey_eg_timestamp":"base64ciphertext"}`
    //	plaintexts, err := k.RecvFromJson(json.NewDecoder(strings.NewReader(jsonText)))
    //	if err == io.EOF {
    //		// break
    //	} else if err != nil {
    //		// panic(err)
    //	}
    //	for k, v := range plaintexts {
    //		fmt.Printf("%s: %v\n", k, v)
    //	}
    RecvFromJson(j *json.Decoder, allMustDecrypt ...bool) (map[string][]byte, error)

    // EncryptToJson sends the plaintext value as ciphertext value per
    // each key in messages via json.Encode to w. If any of the values
    // in messages fail to be encrypted the function will return an
    // error.
    EncryptToJson(messages map[string][]byte, w io.Writer) error
}
```

### func [NewKryptograf](<https://github.com/sa6mwa/kryptograf/blob/main/kryptograf.go#L188>)

```go
func NewKryptograf() Kryptograf
```

NewKryptograf returns a new kryptograf instance with the default encryption key and gzip disabled by default \(the value of kryptograf.GzipByDefault\). Use the method SetEncryptionKey to set your own encryption key \(from a base64 raw standard encoded string\).



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
